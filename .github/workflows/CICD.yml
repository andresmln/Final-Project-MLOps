name: End-to-End MLOps Pipeline

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

# Definimos variables globales para MLFlow como pide el PDF
env:
  MLFLOW_DIR: ${{ github.workspace }}/mlruns
  MLFLOW_TRACKING_URI: file://${{ github.workspace }}/mlruns

jobs:
  # -----------------------------------------------------------
  # 1. ETAPA DE ENTRENAMIENTO (Train & Serialize)
  # -----------------------------------------------------------
  train:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install wheel setuptools
          
          # 1. Mira si existe dentro de la carpeta api/
          if [ -f api/requirements.txt ]; then 
            sed -i '/pywin32/d' api/requirements.txt
            sed -i '/winshell/d' api/requirements.txt
            pip install -r api/requirements.txt
          
          # 2. O si existe en la raíz (aquí entra tu elif)
          elif [ -f requirements.txt ]; then
            sed -i '/pywin32/d' requirements.txt
            sed -i '/winshell/d' requirements.txt
            pip install -r requirements.txt
          fi

          # 3. Instalación de seguridad por si lo anterior falla
          pip install shap optuna xgboost mlflow scikit-learn pandas python-dotenv matplotlib joblib
          
      - name: Train Model & Optimize (Optuna + MLFlow)
          # Ejecuta el entrenamiento. MLFLOW_TRACKING_URI se lee del env global.
        run: python -m mylib.train

      # Guardamos los archivos generados para pasarlos a las siguientes etapas
      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: model-artifacts
          path: |
            model.joblib
            scaler.joblib
            feature_names.joblib
            threshold.joblib
            metrics.json
            mlruns/

  # -----------------------------------------------------------
  # 2. ETAPA DE CONSTRUCCIÓN Y DESPLIEGUE (Docker)
  # -----------------------------------------------------------
  build-and-deploy:
    runs-on: ubuntu-latest
    needs: train  # Espera a que termine el entrenamiento
    permissions:
      contents: read
      packages: write
    
    steps:
      - uses: actions/checkout@v4

      # DESCARGAMOS EL MODELO EN LA CARPETA ESPECIFICA PARA QUE DOCKER LO VEA 
      - name: Download Model Artifacts
        uses: actions/download-artifact@v4
        with:
          name: model-artifacts
          path: api/models_local 

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: api/Dockerfile
          push: true
          
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/mlops-final_project_churn-api:latest

      # Limpieza del directorio MLFlow (requisito académico común)
      - name: Clean MLFlow Directory
        run: rm -rf ${{ env.MLFLOW_DIR }}

  # -----------------------------------------------------------
  # 3. INTERFAZ GRÁFICA (Hugging Face Spaces)
  # -----------------------------------------------------------
  deploy-hf:
    runs-on: ubuntu-latest
    needs: build-and-deploy
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main
      
      # Descargamos los modelos frescos para subirlos a HF
      - name: Download Model Artifacts for HF
        uses: actions/download-artifact@v4
        with:
          name: model-artifacts
          path: .
      
      - name: Push to Hugging Face
        env:
          HF_TOKEN: ${{ secrets.HF_TOKEN }}
          HF_USERNAME: ${{ secrets.HF_USERNAME }}
          HF_SPACE_NAME: ${{ secrets.HF_SPACE_NAME }}
        run: |
          git config --global user.email "action@github.com"
          git config --global user.name "GitHub Action"

          # 1. Crear una rama "huérfana" (sin historia previa)
          #    Esto nos permite empezar desde cero sin borrar la carpeta .git
          git checkout --orphan deploy-branch
          
          # 2. "Des-trackear" todos los archivos actuales de esta nueva rama
          #    Esto deja los archivos en la carpeta, pero Git "olvida" que existen por un momento
          git reset
          
          # 3. Añadir el remoto
          git remote add space https://$HF_USERNAME:$HF_TOKEN@huggingface.co/spaces/$HF_USERNAME/$HF_SPACE_NAME

          # 4. Configurar LFS
          git lfs install
          git lfs track "*.joblib"
          git add .gitattributes

          # 5. Añadir A MANO solo lo que queremos subir
          #    (Aquí es donde EXCLUIMOS el PDF y el ZIP simplemente no añadiéndolos)
          
          # Archivos del modelo y métricas
          git add -f model.joblib scaler.joblib feature_names.joblib threshold.joblib metrics.json
          
          # Archivos de código (Ajusta esto si tus carpetas se llaman diferente)
          git add app.py requirements.txt
          # Si tienes carpetas de código, añádelas así:
          if [ -d "mylib" ]; then git add mylib/; fi
          if [ -d "api" ]; then git add api/; fi
          # Si tienes un Dockerfile
          if [ -f "Dockerfile" ]; then git add Dockerfile; fi

          # 6. Commit y Push
          #    Fíjate en el comando push: enviamos nuestra rama 'deploy-branch' a la rama 'main' del Space
          git commit -m "Deploy clean version (Artifacts + Code)"
          git push --force space deploy-branch:main